#!/usr/bin/env python
# python 2 only, adjust path (or port, I'd love you) as needed
# *not* /usr/bin/env python
# run @ --help for (a little) more information
# MIT licensed.
"""\
primarily a python eval command. auto-formats the result of your expression:
(> indicates the line contains user input)

  > $ @ '1'
    1
  > $ @ '1 + 1'
    2
  > $ @ '"hello world"'
    hello world

has auto-import; looks through your string for module names.
if it finds them, it imports them. shouldn't cause any issues if you don't
mean to use the module:

  > $ @ 'time.time()'
    1397224233.76

if you pass -p, prints x for x in <your expression> on lines:

  > $ @ '[1, 2, 3, 4]'
    [1, 2, 3, 4]
  > $ @ -p '[1, 2, 3, 4]'
    1
    2
    3
    4

if you pass -l, appends ' for line in lines' to your expression:

  > $ @ -pl 'line[::-1]'
  > hello world
    dlrow olleh
  > wheee!
    !eeehw
  > this is fun!
    !nuf si siht

examples from my bash history (try them, they don't bite):

    @ '"|".join(lines)'
    @ -p 'range(10)'
    @ -pl 'line[::-1]
    @ '"%s %s" % (datetime.datetime.now(), line)' -plu
    @ 'math.sqrt(49012)'
    @ 'math.sqrt(150)'
    ... | @ 'line.decode("utf-8").encode("unicode_escape")' -pl | ...
    @ 'x % 5 for x in range(15)'
    @ 'dir()' -p
    @ 'random.SystemRandom().choice("abcdef0123456789") for x in range(30)' -j
    @ 'pprint.pprint(json.loads(inp()))'
    @ 'urllib2.urlopen("google.com").read()'

another great one:

    @ 'variables'
"""


from __future__ import print_function

import re
import itertools
import time
import os
import sys
import codecs
import ast
import token
import tokenize
import contextlib

class _Unbuffered(object):
    def __init__(self, stream):
        self.stream = stream
        self._unbuffered = True

    def write(self, data):
        if type(data) == unicode:
            data = data.encode("utf-8")
        self.stream.write(data)
        if self._unbuffered:
            self.stream.flush()

    def __getattr__(self, attr):
        return getattr(self.stream, attr)


def _debuffer():
    sys.stdout = _Unbuffered(sys.stdout)
    sys.stdout._unbuffered = sys.stdout.isatty()

    sys.stderr = _Unbuffered(sys.stderr)
    sys.stderr._unbuffered = sys.stderr.isatty()

def succeed():
    "Function that exits with a success return code (0)."
    sys.exit(0)

def fail():
    "Function that exits with a failure return code (1)."
    sys.exit(1)

class lines(object):
    def __init__(self):
        self.__doc__ = "Iterable of lines coming in from standard in."

    def __iter__(self):
        return self

    def __repr__(self):
        return "<lines - iterable of lines coming from standard in>"

    def __str__(self):
        return "iterable"

    def next(self):
        line = sys.stdin.readline().decode("utf-8")
        if not line:
            raise StopIteration
        if line.endswith("\n"):
            line = line[:-1]
        return line

def inp():
    "Returns entire standard in as one string."
    return sys.stdin.read().decode("utf-8")

def _hash(hasher, text):
    instance = hasher()
    instance.update(text)
    return instance

def md5(text):
    "md5(text) - compute hex md5 of input string."
    import hashlib
    return _hash(hashlib.md5, text).hexdigest()

def sha256(text):
    "sha256(text) - compute hex sha256 of input string."
    import hashlib
    return _hash(hashlib.sha256, text).hexdigest()


def pairs(iterable):
    "pairs(iterable) -> (s0, s1), (s1,s2), (s2, s3), etc"
    from itertools import tee, izip
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)


_chunks_guard = object()
def chunks(generator, size, pad=_chunks_guard):
    """
    chunks(generator, size, pad=<no pad>) - Yield size chunks from generator.
    fills the last one with pad if provided.
    """
    q = itertools.izip_longest(*[iter(generator)]*size, fillvalue=pad)
    return ([a for a in b if a is not _chunks_guard] for b in q)


def delays(delta, iterable=None):
    "delays(secs, i=itertools.repeat(None)) - Wraps iterator with delays."
    if iterable is None:
        import itertools
        iterable = itertools.repeat(None)
    if not callable(delta):
        if getattr(delta, "total_seconds", None) is not None:
            delta = delta.total_seconds()
        deltafunc = lambda: delta
    else:
        deltafunc = delta
    for x in iterable:
        time.sleep(float(deltafunc()))
        yield x


lines = lines()

class bytes(object):
    def __init__(self):
        self.__doc__ = "Standard in, byte by byte, as an iterator"
        self.iterator = self._go()
        assert self.iterator.next() is None

    def __iter__(self):
        return self.iterator

    def next(self):
        return self.iterator.next()

    def __repr__(self):
        return "<bytes - standard in, byte by byte, as an iterator>"

    def __str__(self):
        return "iterable"

    def _go(self):
        yield None
        if sys.stdout.isatty() and sys.stdout._unbuffered:
            bufsize = 1
        else:
            bufsize = 512

        while True:
            s = sys.stdin.read(bufsize)
            if not s:
                break
            for char in s:
                yield char
bytes = bytes()


def _split_statements(string):

    if string is None:
        return [], None

    operations = [[]]
    for type, tokenstring, start, end, line in tokenize.generate_tokens(iter(string.split("\n")).next):
        if tokenstring.strip() == ";":
            operations.append([])
            continue
        operations[-1].append((type, tokenstring))
    strings = [tokenize.untokenize(o) for o in operations]

    return strings


def _parse_args():
    import argparse
    class Thingy(argparse.RawDescriptionHelpFormatter,
            argparse.ArgumentDefaultsHelpFormatter):
        # argparse's api is weird here
        pass
    parser = argparse.ArgumentParser(epilog=__doc__,
            description="Convenient python eval!",
            formatter_class=Thingy)
    parser.add_argument("-a", "--all", action="store_true",
            help="wrap expression in all()")
    parser.add_argument("-n", "--any", action="store_true",
            help="wrap expression in any()")
    parser.add_argument("-l", "--lines", action="store_true",
            help="make expression iterable per line")
    parser.add_argument("-c", "--chars", action="store_true",
            help="make expression iterable per character")
    parser.add_argument("-b", "--bool", action="store_true",
            help="wrap expression in bool() - important if result will be a bool!")
    parser.add_argument("-u", "--unbuffered", action="store_true",
            help="shut off output buffering")
    parser.add_argument("-p", "--print-each", action="store_true",
            help="print each result from the iterable - good with -l pipelining")
    parser.add_argument("-j", "--print-joined", action="store_true",
            help="print each result from the iterable, no newlines - good for -c pipelining")
    parser.add_argument("-v", "--variables", nargs="*",
            help='use as -v x="hi" y="$there" to add variables to the expression')
    parser.add_argument("string", default=None, nargs="*",
            help="the expression, automatically joined by space if multiple specified")
    parser.add_argument("-d", "--debug", action="store_true",
            help='print debug info for type detection')
    def shell(name):
        if name == "builtin":
            return interact
        elif name == "ipython":
            from IPython import embed
            def e(globbelses):
                globbelses["_ipython_embed"] = embed
                exec "_ipython_embed()" in globbelses
        elif name == "ptpython":
            from ptpython.repl import embed
            
    parser.add_argument("-i", "--interactive", action="store", default=None,
            const=interact, type=shell
            help='launch interactive mode')
    args = parser.parse_args()

    if args.unbuffered:
        sys.stdout._unbuffered = True
        sys.stderr._unbuffered = True
    if not args.string and not args.interactive:
        parser.print_help()
        sys.exit(1)

    string = " ".join(args.string) if args.string else None
    statements, string = _split_statements(string)
    if args.print_joined:
        args.print_each = True

    assert not (args.lines and args.chars), "only -c or -l please"
    actions = len([x for x in [
        args.all,
        args.any,
        args.bool,
        args.print_each
    ] if x])
    assert actions <= 1, (
            "only one of ---all, --any, --bool, or --print_each please")


    if args.lines:
        if string is None:
            string = "line"
        string = "(%s) for line in lines" % string
    if args.chars:
        if string is None:
            string = "char"
        string = "(%s) for char in characters" % string

    if args.all:
        string = "all(%s)" % string
    if args.any:
        string = "any(%s)" % string
    if args.bool:
        string = "bool(%s)" % string

    if not args.variables:
        args.variables = []
    for var in args.variables:
        name, equals, value = var.partition("=")
        assert equals, "please put an equals sign in variable defitions"
        globals()[name] = value

    return (statements, string, args.print_each, args.debug,
            sys.stdout.write if args.print_joined else print)

_available_names = set()
_available = []


class _Importable(object):
    def __init__(self, name, kind):
        self.name = name
        self.kind = kind

    def __repr__(self):
        return "<importable %s: %s>" % (self.kind, self.name)

    def __str__(self):
        return "importable %s" % (self.kind)


_optional_modules = [
    "subprocess",
    "platform",
    "re",
    "string",
    "struct",
    "unicodedata",
    "datetime",
    "pprint",
    "random",
    "math",
    "difflib",
    "decimal",
    "fractions",
    "itertools",
    "functools",
    "operator",
    "json",
    "pickle",
    "glob",
    "fnmatch",
    "shutil",
    "sqlite3",
    "zlib",
    "gzip",
    "bz2",
    "zipfile",
    "tarfile",
    "csv",
    "contextlib",
    "hashlib",
    "time",
    "uu",
    "requests",
    "urllib2",
    "urllib",
    "uuid",
    "urlparse",
    "shlex",
    "inspect",
    "tty",
    "termios",
    "grp",
    "pwd",
    "pty",
    "fcntl",
    "blessings",
    "collections",
    "chardet",
    "twisted",
    "tokenize",
    "token",
    "numpy",
    "scipy",
    "os",
    "sys",
    "codecs",
    "ast",
    "token",
    "tokenize",
]

@contextlib.contextmanager
def _mute_fd(fdnum):
    "Context manager that mutes file descriptor 2"
    if not _debug:
        #print("muting fd 2 (this was written to sys.stderr)", file=sys.stderr)
        #os.write(2, "muting fd 2 (this was written to fd 2)\n")
        p = os.dup(fdnum)
        q = os.open("/dev/null", os.O_WRONLY)
        os.dup2(q, fdnum)
        sys.stderr = os.fdopen(p, "w")
        #print("just muted fd 2 (this was written to sys.stderr)", file=sys.stderr)
        #os.write(2, "just muted fd 2 (this was written to fd 2)\n")

    yield

    if not _debug:
        #print("about to unmute fd 2 (this was written to sys.stderr)", file=sys.stderr)
        #os.write(2, "about to unmute fd 2 (this was written to fd 2)\n")
        os.dup2(p, fdnum)
        os.close(q)
        sys.stderr = os.fdopen(fdnum, "w")
        #print("unmuting fd 2 (this was written to fd sys.stderr)", file=sys.stderr)
        #os.write(2, "unmuting fd 2 (this was written to fd 2)\n")

def _add_modules(globbles, strings):

    def _wanted(_mod, kind=None):
        if kind is not None and _mod not in _available_names:
            _available_names.add(_mod)
            _available.append(_Importable(_mod, kind))
        # to find all mentions of a module name
        # (?:.*(?<!\w)(MODULE_NAME)(?!\w))+(?:.(?!(?<!\w)(MODULE_NAME)(?!\w)))*
        # not sure if I need the hack at the end to make sure there are no
        # repetitions of the module name...

        mod_re = "(?<!\w)(MODULE_NAME)(?!\w)".replace("MODULE_NAME", _mod)
        return any(re.search(mod_re, _s) for _s in strings)

    for _mod in _optional_modules:
        if _wanted(_mod, "module"):
            exec "import %s" % _mod in globbles


    if _wanted("terminal", "pre-initialized blessings instance"):
        import blessings
        terminal = blessings.Terminal(force_styling=True)
        globbles["blessings"] = blessings
        globbles["terminal"] = terminal

    # force non-short-circuit evaluation
    a = _wanted("session", "pre-initialized tensorflow session")
    a = _wanted("sess", "pre-initialized tensorflow session") or a
    a = _wanted("s", "pre-initialized tensorflow session") or a
    a = _wanted("tf", "tensorflow module short-name") or a
    a = _wanted("tensorflow", "tensorflow") or a
    if a:
        with _mute_fd(2):
            import tensorflow
            session = tf.InteractiveSession()
            globbles["session"] = session
            globbles["sess"] = session
            globbles["tensorflow"] = tensorflow
            globbles["tf"] = tensorflow

    if _wanted("np", "numpy module short-name"):
        import numpy as np
        globbles["np"] = np

    _available_itertools = []
    _itertools_values = [
        "count",
        "cycle",
        "repeat",
        "chain",
        "compress",
        "dropwhile",
        "groupby",
        "ifilter",
        "ifilterfalse",
        "islice",
        "imap",
        "starmap",
        "tee",
        "takewhile",
        "izip",
        "izip_longest",
        "product",
        "permutations",
        "combinations",
        "combinations_with_replacement",
    ]
    for _itertool_func in _itertools_values:
        _available_itertools.append(_Importable(_itertool_func, "itertools function"))
        if _wanted(_itertool_func):
            exec "from itertools import %s" % _itertool_func in globbles
        del _itertool_func

    for _avail in _available:
        if _avail.name not in globbles:
            globbles[_avail.name] = _avail

_blacklist = [
    "_format_var",
    "_add_environment_vars",
    "_available",
    "_LazyString",
    "_avail",
    "__doc__",
    "__file__",
    "_available_itertools",
    "_Importable",
    "_itertools_values",
    "_wanted",
    "_mod",
    "_optional_modules",
    "_blacklist",
    "_run",
    "_main",
    "_debuffer",
    "_string",
    "_statements",
    "_shouldprint",
    "_hash",
    "__package__",
    "__name__",
    "_add_modules",
    "_Unbuffered",
    "__builtins__",
    "_statement",
    "variables",
    "_variables",
    "_result",
    "_split_statements",
    "_hasdoc",
    "_old_globals",
]

class _LazyString(object):
    """Class for strings created by a function call.

    The proxy implementation attempts to be as complete as possible, so that
    the lazy objects should mostly work as expected, for example for sorting.

    This is most of the implementation of the `speaklater` package on pypi,
    copy and pasted. this class is BSD licensed, the rest of this file is MIT.
    """
    __slots__ = ('_func', '_args', "_kwargs", "_cache")

    def __init__(self, func, *args, **kwargs):
        self._func = func
        self._args = args
        self._kwargs = kwargs
        self._cache = None

    @property
    def value(self):
        if self._cache is not None:
            return self._cache
        self._cache = self._func(*self._args, **self._kwargs)
        return self._cache

    def __contains__(self, key):
        return key in self.value

    def __nonzero__(self):
        return bool(self.value)

    def __dir__(self):
        return dir(unicode)

    def __iter__(self):
        return iter(self.value)

    def __len__(self):
        return len(self.value)

    def __str__(self):
        return str(self.value)

    def __unicode__(self):
        return unicode(self.value)

    def __add__(self, other):
        return self.value + other

    def __radd__(self, other):
        return other + self.value

    def __mod__(self, other):
        return self.value % other

    def __rmod__(self, other):
        return other % self.value

    def __mul__(self, other):
        return self.value * other

    def __rmul__(self, other):
        return other * self.value

    def __lt__(self, other):
        return self.value < other

    def __le__(self, other):
        return self.value <= other

    def __eq__(self, other):
        return self.value == other

    def __ne__(self, other):
        return self.value != other

    def __gt__(self, other):
        return self.value > other

    def __ge__(self, other):
        return self.value >= other

    def __getattr__(self, name):
        if name == '__members__':
            return self.__dir__()
        return getattr(self.value, name)

    def __getstate__(self):
        return self._func, self._args, self._kwargs

    def __setstate__(self, tup):
        self._func, self._args, self._kwargs = tup

    def __getitem__(self, key):
        return self.value[key]

    def __copy__(self):
        return self

    def __repr__(self):
        try:
            return 'l' + repr(self.value)
        except Exception:
            return '<%s broken>' % self.__class__.__name__

def _hasdoc(value):
    doc = getattr(value, "__doc__", None)
    return doc != getattr(type(value), "__doc__", None) and doc

def _format_var(name, value):
    def truncate_to_line(v):
        s = v.split("\n")
        if len(s) > 1 or len(s[0]) >= 80:
            v = s[0][:77] + "..."
        return v

    f = "- `{name}`: {value}"

    
    if type(value) == _LazyString:
        value = "<Lazy String>"
    elif _hasdoc(value):
        simpledesc = None
        if type(value) == type(_format_var):
            simpledesc = "function"
        elif type(value) == type(print):
            simpledesc = "builtin"
        elif type(value) == type:
            simpledesc = "class"
        elif type(value) == type(token):
            simpledesc = "module"
        elif type(value) == type(str.join):
            simpledesc = "method"
        elif type(value) == type("".join):
            simpledesc = "bound method"
        else:
            simpledesc = str(value)

        value = ("%s - %s" % (simpledesc, value.__doc__)).strip()
        value = truncate_to_line(value)

    elif type(value) == str or type(value) == unicode:
        value = repr(truncate_to_line(value))
    else:
        value = str(value)

    return f.format(name=name, value=value)


def show(x):
    def f(d, blist):
        return "\n".join(
            _format_var(name, value)
            for name, value in sorted(d.items(), key=lambda x: x[0]))

    m = dict((q, getattr(x, q)) for q in dir(x) if not q.startswith("__"))
    if _hasdoc(x):
        print(x.__doc__)
        print()

    if m:
        print("Attributes")
        print("==============\n")
        print(f(m, {}))


def _variables(g, oldglobals):
    def f(d, blist):
        return "\n".join(
            _format_var(name, value)
            for name, value in sorted(d.items(), key=lambda x: x[0])
            if name not in blist)
    blist = set(_blacklist)
    shell_vars = f(os.environ, blist)
    blist |= set(os.environ.keys())

    modules = f(dict((x.name, x) for x in _available), blist)
    blist |= set([x.name for x in _available])

    iterfuncs = f(dict((x.name, x) for x in _available_itertools), blist)
    blist |= set([x.name for x in _available_itertools])

    oldremaining = f(oldglobals, blist)
    blist |= set(oldglobals.keys())

    uservars = f(g, blist)

    tail = ""
    if uservars:
        tail = ("\n"
            "Your variables\n"
            "==============\n"
            "\n"
            "{}\n"
        ).format(uservars)

    return (
        "Available names:\n"
        "================\n"
        "\n"
        "Variables from shell environment\n"
        "--------------------------------\n"
        "\n"
        "{shell_vars}\n"
        "\n"
        "Imported and auto-importing modules\n"
        "-----------------------------------\n"
        "\n"
        "'importable' modules will automatically import on use.\n"
        "\n"
        "{modules}\n"
        "\n"
        "extra: these functions will be auto-imported from itertools:\n"
        "\n"
        "{iterfuncs}\n"
        "\n"
        "Utilities and globals specific to @\n"
        "-----------------------------------\n"
        "\n"
        "{remaining}\n"
        "{tail}"
    ).format(shell_vars=shell_vars, modules=modules, iterfuncs=iterfuncs,
            remaining=oldremaining, tail=tail)


def _add_environment_vars(glob, outer_dir):
    original_globals = dict(glob)

    overlap = set(original_globals) & set(os.environ)
    overlap2 = set(outer_dir + dir(__builtins__)) & set(os.environ)
    if overlap and _debug:
        print("WARNING: variable overlap: %r" % overlap)
    elif overlap2 and _debug:
        print("WARNING: builtin overlap: %r" % overlap2)


    glob.update(os.environ)
    glob.update(original_globals)


def run(statements, expression, run_globals):
    try:
        for statement in statements:
            exec statement in _derp
        if not expression.strip():
            _result = None
        else:
            _result = eval("(%s)" % expression, _derp)

        if "tensorflow" in sys.modules:
            import tensorflow
            if isinstance(_result, tensorflow.python.framework.ops.Tensor):
                if "session" not in globals():
                    session = tensorflow.InteractiveSession()
                _result = session.run(_result)
    except KeyboardInterrupt:
        sys.stderr.write("@ killed (ctrl+d to close cleanly)")
        fixme: return fail
    except BaseException as e:
        import traceback
        x = traceback.format_exc().split("\n")
        y = "\n".join(x[4:])
        sys.stderr.write(y)
        sys.stderr.flush()
        fixme: return fail


    if _result is None:
        _result = True

    if not isinstance(_result, basestring) or isinstance(_result, _LazyString):
        try:
            iterator = iter(_result)
        except TypeError as e:
            if getattr(_result, "__iter__", None) is not None:
                raise
        else:
            if _shouldprint:
                for x in iterator:
                    if _debug:
                        print("printed iterator:", x)
                    else:
                        print(x)
            else:
                result2 = list(iterator)
                try:
                    # lol hax
                    is_repeatable_iterable = (
                        "numpy" in str(type(_result))
                        or (
                            iterator is not _result
                            and result2 == list(iter(_result))
                        )
                    )
                except ValueError:
                    # assume yes, because annoying
                    is_repeatable_iterable = True
                if is_repeatable_iterable: # check for repeatability
                    if _debug:
                        print("repeatable iterable:", _result, result2)
                    else:
                        print(_result)
                elif any(x != None for x in result2):
                    if _debug:
                        print("listed iterable with at least one non-none:", result2)
                    else:
                        print(result2)
                elif _debug:
                    print("nothing to print")
            fixme: return succeed

    if not isinstance(_result, bool) or _shouldprint:
        if _hasdoc(_result) and repr(_result) == str(_result):
            if _debug:
                print("printed docstring:", _result.__doc__)
            else:
                print(_result.__doc__)
        else:
            if _debug:
                print("primary print:", _result)
            else:
                print(_result)

    if isinstance(_result, bool):
        if _debug:
            print("bool result, returning exit code:", 0 if _result else 1, _result)

        if _result:
            fixme: return succeed
        else:
            fixme: return fail
    else:
        if _debug:
            print("non-bool result, returning exit code 0 (true)")
        fixme: return succeed


if __name__ == "__main__":
    _debuffer()

    _statements, _string, _shouldprint, _debug, print = _parse_args()
    del _parse_args

    _add_modules(globals(), _statements + [_string])

    variables = _LazyString(lambda: _variables(run_globals, old_globals))

    run_globals = dict(globals())
    _add_environment_vars(_command_globals, dir())
    old_globals = dict(globals())

    run(_statements, _string, run_globals)
