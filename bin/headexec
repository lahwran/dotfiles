#!/usr/bin/python
from __future__ import print_function
import subprocess
import signal
#import pudb; pudb.set_trace()
import sys
import time
import blessed
term = blessed.Terminal()
argv = sys.argv[1:]
def get_linecount(string):
    lines = term.wrap(string)
    return len(lines)

def print_what_we_can(printed_so_far, print_queue):
    if not print_queue:
        return
    stopped = False
    skipped_lines = []
    for index, line in enumerate(print_queue.split("\n")):
        if index > 0:
            line = "\n" + line
        if not stopped and get_linecount(printed_so_far + line) < term.height:
            printed_so_far += line
            sys.stdout.write(line)
            sys.stdout.flush()
        else:
            stopped = True
            skipped_lines.append(line)
    return printed_so_far, "".join(skipped_lines)

def execute(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Poll process for new output until finished
    now = time.time()
    last = 0
    printed_so_far = ""
    print_queue = ""
    print(term.height)
    try:
        while process.poll() is None:
            if now - last > 0.01:
                size = 1
            else:
                size *= 2

            last = time.time()
            content = process.stdout.read(size)
            now = time.time()
            print_queue += content
            printed_so_far, print_queue = print_what_we_can(printed_so_far, print_queue)
            if print_queue:
                print("Printed line count:", get_linecount(printed_so_far))
                raise KeyboardInterrupt
        print_queue += process.stdout.read()
        print_what_we_can(printed_so_far, print_queue)
    except KeyboardInterrupt:
        process.send_signal(signal.SIGINT)
        for x in range(30):
            time.sleep(0.002)
            if process.poll(): return process.poll()
        process.terminate()
        for x in range(60):
            time.sleep(0.002)
            if process.poll(): return process.poll()
        process.kill()
        for x in range(100):
            time.sleep(0.01)
            if process.poll(): return process.poll()
        print("Process somehow still alive after kill... This shouldn't happen but is imaginable, your kernel may be fucked up or something")
    return process.poll()


sys.exit(execute(argv))
