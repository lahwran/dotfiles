#!/usr/bin/env python3
import sys
import subprocess
import os
import time
import blessed
from watchdog.observers import Observer
from watchdog.tricks import Trick
#import pudb; pudb.set_trace()
term = blessed.Terminal()

if len(sys.argv) == 1 or sys.argv[1].replace("--", "") in ["help", "h"]:
    print("Usage:")
    print()
    print("watchmeexec [[pattern...] --] binary [args ...]")
    sys.exit(1)

if "--" in sys.argv:
    idx = sys.argv.index("--")
    path_patterns = sys.argv[1:idx]
    cmd = sys.argv[idx+1:]
else:
    path_patterns = []
    cmd = sys.argv[1:]

#watchmedo shell-command -c "clear; $command" 

#patterns, ignore_patterns = parse_patterns(args.patterns,
#                                            args.ignore_patterns)
patterns = []


#subprocess.call(["python", "-c", headexec] + cmd)

def invoke():
    subprocess.call(["headexec", "__do_clear"] + cmd)

class CommandTrick(Trick):

    """Executes shell commands in response to matched events."""

    def __init__(self, patterns=None, ignore_patterns=None,
                 ignore_directories=False, wait_for_process=False,
                 drop_during_process=False):
        super(CommandTrick, self).__init__(patterns, ignore_patterns,
                                                ignore_directories)
        self.wait_for_process = wait_for_process
        self.drop_during_process = drop_during_process
        self.process = None

    def on_any_event(self, event):
        #from string import Template

        #if self.drop_during_process and self.process and self.process.poll() is None:
        #    return

        #if event.is_directory:
        #    object_type = 'directory'
        #else:
        #    object_type = 'file'

        #context = {
        #    'watch_src_path': event.src_path,
        #    'watch_dest_path': '',
        #    'watch_event_type': event.event_type,
        #    'watch_object': object_type,
        #}

        #if has_attribute(event, 'dest_path'):
        #    context.update({'watch_dest_path': event.dest_path})

        #command = Template(command).safe_substitute(**context)
        time.sleep(0.1)
        invoke()

# todo: this is actually cartesian product between patterns and dirs but WHATEVER
patterns = []
dirnames = {}
executable = cmd[0]
if os.path.basename(executable) in ["python", "python3", "python2", "bash", "ruby", "node", "nodejs", "python3.6", "python3.5", "python3.7"]:
    # todo make less naive
    executable = cmd[1]
executable = os.path.abspath(executable)
for pathpattern in path_patterns + [executable]:
    pathpattern=os.path.abspath(pathpattern)
    if "**" in pathpattern:
        before, stars, after = pathpattern.partition("**")
        dirname = os.path.dirname(before)
        base = os.path.basename(before)
        dirnames[dirname] = True
        patterns.append(base+stars+after)
    else:
        dirname = os.path.dirname(pathpattern)
        basename = os.path.dirname(pathpattern)
        assert "*" not in dirname
        dirnames.setdefault(dirname, False)
        patterns.append(basename)
handler = CommandTrick(
                            patterns=patterns,
                            ignore_patterns=[], #ignore_patterns,
                            ignore_directories=[], #args.ignore_directories,
                            wait_for_process=True,
                            drop_during_process=False)
observer = Observer(timeout=30)


#cmd="$(python -c 'import sys,pipes;print(" ".join(pipes.quote(x) for x in sys.argv[1:]))' "$@")"
#bin="$1"
#dir="$(dirname $bin)"
##clear
#"$@"



with term.fullscreen():
    invoke()
    for dirname, recursive in dirnames.items():
        observer.schedule(handler, dirname, recursive)

    try:
        observer.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("Stopping")
            observer.stop()
            print("Done stopping")
    except KeyboardInterrupt:
        print("Shutting down forcefully?")
        pass
        print("Stuff may or may not actually happen")
