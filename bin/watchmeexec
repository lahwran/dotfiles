#!/usr/bin/python
import sys
import os
import time
import blessed

if "--" in sys.argv:
    idx = sys.argv.index("--")
    path_patterns = sys.argv[1:idx]
    cmd = sys.argv[idx+1:]
else:
    path_patterns = []
    cmd = sys.argv[1:]

if not os.path.exists(cmd[0]):
    cmd = 

# todo: this is actually cartesian product between patterns and dirs but WHATEVER
patterns = []
directories = []
for 

cmd="$(python -c 'import sys,pipes;print(" ".join(pipes.quote(x) for x in sys.argv[1:]))' "$@")"
bin="$1"
dir="$(dirname $bin)"
#clear
"$@"
#watchmedo shell-command -c "clear; $command" 

#patterns, ignore_patterns = parse_patterns(args.patterns,
#                                            args.ignore_patterns)
patterns = []
from watchdog.observers import Observer
from watchdog.tricks import Trick
class ShellCommandTrick(Trick):

    """Executes shell commands in response to matched events."""

    def __init__(self, shell_command=None, patterns=None, ignore_patterns=None,
                 ignore_directories=False, wait_for_process=False,
                 drop_during_process=False):
        super(ShellCommandTrick, self).__init__(patterns, ignore_patterns,
                                                ignore_directories)
        self.shell_command = shell_command
        self.wait_for_process = wait_for_process
        self.drop_during_process = drop_during_process
        self.process = None

    def on_any_event(self, event):
        from string import Template

        if self.drop_during_process and self.process and self.process.poll() is None:
            return

        if event.is_directory:
            object_type = 'directory'
        else:
            object_type = 'file'

        context = {
            'watch_src_path': event.src_path,
            'watch_dest_path': '',
            'watch_event_type': event.event_type,
            'watch_object': object_type,
        }

        if has_attribute(event, 'dest_path'):
            context.update({'watch_dest_path': event.dest_path})
        command = self.shell_command

        command = Template(command).safe_substitute(**context)
        self.process = subprocess.Popen(command)
        if self.wait_for_process:
            self.process.wait()
handler = ShellCommandTrick(shell_command=args.command,
                            patterns=patterns,
                            ignore_patterns=[], #ignore_patterns,
                            ignore_directories=[], #args.ignore_directories,
                            wait_for_process=args.wait_for_process,
                            drop_during_process=args.drop_during_process)
observer = Observer(timeout=args.timeout)

for pathname in set(pathnames):
    observer.schedule(event_handler, pathname, recursive)

try:
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
except KeyboardInterrupt:
    pass
