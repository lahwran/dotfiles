#!/usr/bin/python
import sys
import subprocess
import os
import time
import blessed
from watchdog.observers import Observer
from watchdog.tricks import Trick
term = blessed.Terminal()

if "--" in sys.argv:
    idx = sys.argv.index("--")
    path_patterns = sys.argv[1:idx]
    cmd = sys.argv[idx+1:]
else:
    path_patterns = []
    cmd = sys.argv[1:]

#watchmedo shell-command -c "clear; $command" 

#patterns, ignore_patterns = parse_patterns(args.patterns,
#                                            args.ignore_patterns)
patterns = []

headexec = """
import subprocess, sys, time, blessed
term = blessed.Terminal()
argv = sys.argv[1:]
def get_linecount(string):
    lines = term.wrap(string)
    return len(lines)
def execute(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    # Poll process for new output until finished
    now = time.time()
    last = 0
    printed_so_far = ""
    print_queue = ""
    try:
        while process.poll() is None:
            if now - last > 0.001:
                size = 1
            else:
                size = 32

            last = time.time()
            content = process.stdout.read(size)
            now = time.time()
            print_queue += content
            if get_linecount(printed_so_far + print_queue) < term.height:
                sys.stdout.write(print_queue)
                sys.stdout.flush()
                printed_so_far += print_queue
                print_queue = ""
            else:
                raise KeyboardInterrupt
    except KeyboardInterrupt:
        process.interrupt(signal.SIGINT)
        for x in range(30):
            time.sleep(0.002)
            if process.poll(): return process.poll()
        process.terminate()
        for x in range(60):
            time.sleep(0.002)
            if process.poll(): return process.poll()
        process.kill()
        for x in range(100):
            time.sleep(0.01)
            if process.poll(): return process.poll()
        print("Process somehow still alive after kill... This shouldn't happen but is imaginable, your kernel may be fucked up or something")
    return process.poll()



        
sys.exit(execute(argv))
"""

subprocess.call(["python", "-c", headexec] + cmd)

'''
class ShellCommandTrick(Trick):

    """Executes shell commands in response to matched events."""

    def __init__(self, shell_command=None, patterns=None, ignore_patterns=None,
                 ignore_directories=False, wait_for_process=False,
                 drop_during_process=False):
        super(ShellCommandTrick, self).__init__(patterns, ignore_patterns,
                                                ignore_directories)
        self.shell_command = shell_command
        self.wait_for_process = wait_for_process
        self.drop_during_process = drop_during_process
        self.process = None

    def on_any_event(self, event):
        #from string import Template

        if self.drop_during_process and self.process and self.process.poll() is None:
            return

        if event.is_directory:
            object_type = 'directory'
        else:
            object_type = 'file'

        #context = {
        #    'watch_src_path': event.src_path,
        #    'watch_dest_path': '',
        #    'watch_event_type': event.event_type,
        #    'watch_object': object_type,
        #}

        #if has_attribute(event, 'dest_path'):
        #    context.update({'watch_dest_path': event.dest_path})
        command = self.shell_command

        #command = Template(command).safe_substitute(**context)
        self.process = subprocess.Popen(["python", "-c", headexec] + command)
        if self.wait_for_process:
            self.process.wait()
handler = ShellCommandTrick(shell_command=args.command,
                            patterns=patterns,
                            ignore_patterns=[], #ignore_patterns,
                            ignore_directories=[], #args.ignore_directories,
                            wait_for_process=args.wait_for_process,
                            drop_during_process=args.drop_during_process)
observer = Observer(timeout=args.timeout)

# todo: this is actually cartesian product between patterns and dirs but WHATEVER
patterns = []
directories = []
for 

cmd="$(python -c 'import sys,pipes;print(" ".join(pipes.quote(x) for x in sys.argv[1:]))' "$@")"
bin="$1"
dir="$(dirname $bin)"
#clear
"$@"

with term.fullscreen():
    for pathname in set(pathnames):
        observer.schedule(event_handler, pathname, recursive)

    try:
        observer.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()
    except KeyboardInterrupt:
        pass
        '''
